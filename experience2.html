<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - collada - skinning</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #000;
            font-family:Monospace;
            font-size:13px;
            text-align:center;
            background-color: #000;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }
        a {
            color: #f00;
        }
        .jointTarget {
            position: fixed;
            background-color: #ff0000;
            z-index: 1000;
            width: 50px;
            height: 50px;
        }
        #console{
            /*display: none;*/
            position: fixed;
            background-color: #ffffff;
            color: #000000;
            z-index: 1000;
            width: 100%;
            text-align: center;
            height: 45px;
            padding-top: 5px;
            font-size: 30px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
<div id="console"></div>
<div id="container"></div>

<script src="js/three.min.js"></script>
<script src="js/ColladaLoader.js"></script>
<script src="js/Detector.js"></script>
<script src="js/jquery.min.js"></script>
<script>
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
var container, currentFrame=0;
var camera, scene, renderer, backgroundScene, backgroundCamera, avatar;
var targetList = [];
var intersects = [];
var mousePosDown, mousePosUp;
var animation;
var animationState;
var clock = new THREE.Clock();
init();
function init() {
    container = document.getElementById( 'container' );
    scene = new THREE.Scene();
    var axeX, axeY, axeZ;
    var axeGenerator = function(x, y, z){
        var axeGeometry = new THREE.Geometry();
        axeGeometry.vertices.push(
                new THREE.Vector3( 0, 0, 0 ),
                new THREE.Vector3( x, y, z )
        );
        return axeGeometry;
    }
    axeX = new THREE.Line(axeGenerator(100,0,0), new THREE.LineBasicMaterial({color:0xff0000}));
    axeY = new THREE.Line(axeGenerator(0,100,0), new THREE.LineBasicMaterial({color:0x00ff00}));
    axeZ = new THREE.Line(axeGenerator(0,0,100), new THREE.LineBasicMaterial({color:0x0000ff}));
    scene.add(axeX);
    scene.add(axeY);
    scene.add(axeZ);
    camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 0, 0, 500);
    camera.lookAt( new THREE.Vector3(0,0,0));
    camera.up.x=0;
    camera.up.y=0;
    camera.up.z=0;
    camera.updateProjectionMatrix();
    var light = new THREE.DirectionalLight(0xF2D9B4,1.5);
    light.castShadow=true;
    light.position.set(1,2,3);
    light.lookAt(new THREE.Vector3(1,2,0));
    scene.add( light );
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor( 0xfff4e5 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.sortObjects = false;
    container.appendChild( renderer.domElement );
    /*
     * Bones :
     *    1 : buste
     *   12 : bras droit
     *   13: bras gauche
     */
    loadAvatar("male_caucasian_anim_fin.dae",function(){
        //On affiche la position des bones qui nous intéressent pour déterminer la position des points d'ancrages pour l'interaction tactile
        var idBones = [0,1,6,9,12,10,13];
        avatar.translateX(-100);
        avatar.translateY(-80);

        avatar.updateMatrixWorld(true);
//            avatar.rotateY(THREE.Math.degToRad(75));
        var posBrasDroit = avatar.skeleton.bones[17].getWorldPosition();
        loadConsole();
        targetList = getTargetList();
        document.addEventListener('mousedown',hitTarget)
    });
    var texture = THREE.ImageUtils.loadTexture( 'img/env.jpg' );
    var backgroundMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2, 0),
            new THREE.MeshBasicMaterial({
                map: texture
            }));
    backgroundMesh .material.depthTest = false;
    backgroundMesh .material.depthWrite = false;
    // Create your background scene
    backgroundScene = new THREE.Scene();
    backgroundCamera = new THREE.Camera();
    backgroundScene .add(backgroundCamera );
    backgroundScene .add(backgroundMesh);
    window.addEventListener( 'resize', onWindowResize, false );
    render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
}

function render() {
    requestAnimationFrame( render, renderer.domElement );
    renderer.autoClear = false;
    renderer.antialias=true;
    renderer.clear();
    renderer.render( backgroundScene, backgroundCamera);
    renderer.render( scene, camera );
}

/*********************************
 * @description Load the .dae file according to the name et initialize it in the scene
 * @param name
 * @param callback
 */
function loadAvatar(name,callback){
    var loader = new THREE.ColladaLoader();
    loader.load( "3D/dae/Remy/"+name, function (collada) {
        avatar = collada.skins[0];
        avatar.normalizeSkinWeights();
        console.log(avatar);
        scene.add(avatar);
        var skeleton = avatar.skeleton;
        avatar.material.materials[6].shininess=0;
        // create a smooth skin
        // On active la manipulation des bones sur tous les matériaux qui composent un mesh
        for(var i=0;i<avatar.material.materials.length;i++){
            avatar.material.materials[i].skinning=true;
        }
        avatar.castShadow = true;
        avatar.receiveShadow= false;
        avatar.skeleton.useVertexTexture = false;

        animation = new THREE.Animation( avatar, avatar.geometry.animation );
        animation.loop = true;
        animation.timeScale = 0.7;

        skeleton.bones[12].rotateZ(THREE.Math.degToRad(30));
        skeleton.bones[12].rotateX(THREE.Math.degToRad(-15));
        skeleton.bones[13].rotateZ(THREE.Math.degToRad(-30));
        skeleton.bones[13].rotateX(THREE.Math.degToRad(-15));
        avatar.updateMatrixWorld(true);
        callback();
    } );
}
function loadConsole(msg){
    $("#console").text(msg);
}
/*******************************************************
 * @description Couch de dialogue avatar/touchInterface
 *******************************************************/
function getTargetList(){
    avatar.updateMatrixWorld(true);
    var res =[];
    var idBonesTargeted = [17,18];
    for(var i= 0; i<idBonesTargeted.length;i++){
        var target = planeGenerator(0.1,0.1,"#00FF00");
        var pos = avatar.skeleton.bones[idBonesTargeted[i]].getWorldPosition();
        target.position.set(pos.x,pos.y,pos.z);
        target.name = avatar.skeleton.bones[idBonesTargeted[i]].name;
        console.log(target.name);
        scene.add(target);
        res.push(target);
    }
    return res;
};
function updateTargets(){
    avatar.updateMatrixWorld(true);
}
function hitTarget(evt){
    var vector = mouseToWorld(evt);
    mousePosDown = vector.clone();
    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
    intersects = raycaster.intersectObjects(targetList);
    document.addEventListener("mouseup",onMouseUp);
    if(intersects.length>0){
        loadConsole(""+intersects[0].object.name);
        document.addEventListener("mousemove",onMouseMove);
    }
}
function onMouseUp(evt){
    if(intersects.length>0){
    } else {
        var vector = mouseToWorld(evt);
        mousePosUp = vector.clone();
        loadConsole(Math.abs(mousePosUp.x-mousePosDown.x));
        var long = mousePosUp.x-mousePosDown.x;
        if(Math.abs(long) > 10) {
            if (mousePosDown.x < mousePosUp.x) {
                avatar.rotation.y = THREE.Math.degToRad(0);
            }
            else {
                avatar.rotation.y = THREE.Math.degToRad(-180);
            }
            start((long) / (Math.abs(long)/2), (Math.abs(long)/2));
        }
    }
}
function onMouseMove(evt){
    if(intersects.length>0){
        var target = intersects[0].object;
        var mousePosMove =  mouseToWorld(evt);
        switch (target.name){
            case 'rHand':
                var angle = Math.acos(dotProduct(mousePosDown.normalize(),mousePosMove.normalize));
                console.log(avatar.skeleton.bones[12].rotation);
                break;
            case 'lHand':
                break;
            case '':
                break;
        }
    } else {
    }
}
function dotProduct(v1,v2){
    return v1.x*v2.x+v1.y*v2.y+v1.z* v2.z;
}
function mouseToWorld(evt){
    var mouseX = (evt.clientX/window.innerWidth)*2-1;
    var mouseY = -(evt.clientY/window.innerHeight)*2+1;
    var vector = new THREE.Vector3(mouseX,mouseY,0.99799794);//0.99799794
    vector.unproject(camera);
    return vector;
}
function worldToScreen(pos) {
    var p  = pos.clone();
    var vector = p.project(camera);
    vector.x = (vector.x + 1) / 2 * window.innerWidth;
    vector.y = -(vector.y - 1) / 2 * window.innerHeight;
    return vector;
}
function planeGenerator (width,height,color){
    var planeGeometry = new THREE.PlaneBufferGeometry( width, height);
    var material = new THREE.MeshBasicMaterial( {color: color, wireframe:false} );
    return new THREE.Mesh( planeGeometry, material );
};

/*******************************************************
 * Fonctions d'animation de l'avatar
 *******************************************************/
function start(translation, nbFrame) {
    if (!animationState) {
        animation.play();
        loop(translation, nbFrame);
    }
}

function stop() {
    if (animationState) {
        animation.stop();
        window.cancelAnimationFrame(animationState);
        animationState = undefined;
        currentFrame = 0;
        avatar.updateMatrixWorld();
        console.log(avatar.position.x);
    }
}


function loop(translation, nbFrame){
    animationState = requestAnimationFrame(function(){loop(translation, nbFrame)}, renderer.domElement);
    THREE.AnimationHandler.update(clock.getDelta());
    avatar.position.x+=translation;
    currentFrame++;
    if(currentFrame >= nbFrame){
        stop();
    }
}

</script>

</body>
</html>