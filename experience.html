<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - collada - skinning</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #000;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;

            background-color: #000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }

        a {

            color: #f00;
        }

        .jointTarget {
            position: fixed;
            background-color: #ff0000;
            z-index: 1000;
            width: 50px;
            height: 50px;
        }

        #console {
            /*display: none;*/
            position: fixed;
            background-color: #ffffff;
            color: #000000;
            z-index: 1000;
            width: 100%;
            text-align: center;
            height: 45px;
            padding-top: 5px;
            font-size: 30px;
            opacity: 0.8;
        }

        #containerObjet {
            position: fixed;
            height: 39%;
            width: 15%;
            top: 24%; /*margin-top: 207px;*/
            left: 72%; /*margin-left: 922px;*/
            -webkit-perspective: 198px;
            perspective: 198px;
            -webkit-transform: rotate(-90deg);
            transform: rotate(-90deg);
        }

        #objet {
            /*padding: 12% 11%;*/
            width: 91%;
            height: 92%;
            position: absolute;
            border: 1px solid black;
            background-color: red;
            -webkit-transform: rotateX(12deg);
            transform: rotateX(12deg);
            color: red;
        }

    </style>
</head>
<body>
<div id="console"></div>
<div id="container">
    <div id="containerObjet">
        <div id="objet">test</div>
    </div>
</div>

<script src="js/three.min.js"></script>
<script src="js/ColladaLoader.js"></script>
<script src="js/Detector.js"></script>
<script src="js/jquery.min.js"></script>
<script>

    if (!Detector.webgl) Detector.addGetWebGLMessage();

    var container, stats;
    var camera, scene, renderer, backgroundScene, backgroundCamera, avatar;
    var targetList = [];
    var idBonesTargeted = [14, 17, 18];
    var intersects = [];
    var mousePosDown;
    var mousePosMove;
    var clock = new THREE.Clock();
    var offsetWidth=0,offsetHeight=0;
    init();

    function init() {

        container = document.getElementById('container');

        scene = new THREE.Scene();

//        var axeX, axeY, axeZ;
//
//        var axeGenerator = function(x, y, z){
//            var axeGeometry = new THREE.Geometry();
//            axeGeometry.vertices.push(
//                    new THREE.Vector3( 0, 0, 0 ),
//                    new THREE.Vector3( x, y, z )
//            );
//            return axeGeometry;
//        }
//
//        axeX = new THREE.Line(axeGenerator(100,0,0), new THREE.LineBasicMaterial({color:0xff0000}));
//        axeY = new THREE.Line(axeGenerator(0,100,0), new THREE.LineBasicMaterial({color:0x00ff00}));
//        axeZ = new THREE.Line(axeGenerator(0,0,100), new THREE.LineBasicMaterial({color:0x0000ff}));
//
//        scene.add(axeX);
//        scene.add(axeY);
//        scene.add(axeZ);
        var axisHelper = new THREE.AxisHelper(100);
        scene.add(axisHelper);
        /***************
         *    CAMERA   *
         **************/
        camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 0, 500);
        camera.updateProjectionMatrix(true);
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        camera.up.set(0, 0, 0);

        /***************
         *    LIGHT    *
         **************/
        var light = new THREE.DirectionalLight(0xF2D9B4, 1.5);
        light.castShadow = true;
        light.position.set(1, 2, 3);
        light.lookAt(new THREE.Vector3(1, 2, 0));
        scene.add(light);

        /***************
         *  RENDERER   *
         **************/
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor(0xfff4e5);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;

        container.appendChild(renderer.domElement);


        /*
         * Bones :
         *    1 : buste
         *   12 : bras droit
         *   13: bras gauche
         */
        loadObject();
        loadAvatar("male_caucasian.dae", function () {
            //On affiche la position des bones qui nous intéressent pour déterminer la position des points d'ancrages pour l'interaction tactile
            var idBones = [0, 1, 6, 9, 12, 10, 13];
            avatar.translateX(0);
            avatar.translateY(-80);
            avatar.updateMatrixWorld(true);
//            avatar.rotateY(THREE.Math.degToRad(75));
            var posBrasDroit = avatar.skeleton.bones[17].getWorldPosition();

            targetList = getTargetList();
            $(document).on('touchstart', hitTarget);
        });

        var texture = THREE.ImageUtils.loadTexture('img/env.jpg');
        var backgroundMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2, 0),
                new THREE.MeshBasicMaterial({
                    map: texture
                }));

        backgroundMesh.material.depthTest = false;
        backgroundMesh.material.depthWrite = false;

        // Create your background scene
        backgroundScene = new THREE.Scene();
        backgroundCamera = new THREE.Camera();
        backgroundScene.add(backgroundCamera);
        backgroundScene.add(backgroundMesh);
        window.addEventListener('resize', onWindowResize, false);

        animate();

    }
    function onWindowResize() {

        camera.aspect = 16 / 9;
        camera.updateProjectionMatrix();

//        renderer.setSize(window.innerWidth, window.innerHeight);

        if(window.innerWidth / window.innerHeight > 16 / 9){
            offsetWidth = window.innerWidth - 16 * window.innerHeight / 9;
            offsetHeight = 0;
            renderer.setSize(window.innerWidth - offsetWidth, window.innerHeight);
            $('canvas').css({'marginTop':'0'});
        }else{
            offsetHeight = window.innerHeight - 9 * window.innerWidth / 16;
            offsetWidth = 0;
            renderer.setSize(window.innerWidth, window.innerHeight - offsetHeight);
            $('canvas').css({'marginTop':offsetHeight/2});
        }

        loadObject();
    }
    function animate() {

        requestAnimationFrame(animate, renderer.domElement);

        THREE.AnimationHandler.update(clock.getDelta());

        renderer.autoClear = false;
        renderer.antialias = true;
        renderer.clear();
        renderer.render(backgroundScene, backgroundCamera);
        renderer.render(scene, camera);

    }
    /*********************************
     * @description Load the .dae file according to the name et initialize it in the scene
     * @param name
     * @param callback
     */
    function loadAvatar(name, callback) {
        var loader = new THREE.ColladaLoader();
        loader.load("3D/dae/" + name, function (collada) {
            avatar = collada.skins[0];
            avatar.normalizeSkinWeights();
            console.log(avatar);
            scene.add(avatar);
            var skeleton = avatar.skeleton;

            avatar.material.materials[6].shininess = 0;

            // create a smooth skin
            // On active la manipulation des bones sur tous les matériaux qui composent un mesh
            for (var i = 0; i < avatar.material.materials.length; i++) {
                avatar.material.materials[i].skinning = true;
            }
            avatar.castShadow = true;
            avatar.receiveShadow = false;
            avatar.skeleton.useVertexTexture = false;
            skeleton.bones[12].rotateZ(THREE.Math.degToRad(30));
            skeleton.bones[12].rotateX(THREE.Math.degToRad(-15));
            skeleton.bones[13].rotateZ(THREE.Math.degToRad(-30));
            skeleton.bones[13].rotateX(THREE.Math.degToRad(-15));
            avatar.rotateY(THREE.Math.degToRad(75));
            avatar.updateMatrixWorld(true);

            callback();
        });
    }

    function loadConsole(msg) {
        $("#console").text(msg);
    }

    function loadObject(){
        $('#containerObjet').css({
            'top': 0.24*window.innerHeight+offsetHeight/2,
            'left': 0.72*window.innerWidth+offsetWidth/2
        })
        loadConsole(window.innerWidth+"-"+window.innerHeight);
    }


    /*******************************************************
     * @description Couch de dialogue avatar/touchInterface
     *******************************************************/

    function getTargetList() {
        avatar.updateMatrixWorld(true);
        var res = [];
        for (var i = 0; i < idBonesTargeted.length; i++) {
            var target = planeGenerator(8, 20, "#01B0F0");
            var pos = avatar.skeleton.bones[idBonesTargeted[i]].getWorldPosition();
            target.position.set(pos.x, pos.y, pos.z);
            target.name = avatar.skeleton.bones[idBonesTargeted[i]].name;
            scene.add(target);
            res.push(target);
        }
        //On créé la cible de rotation de l'avatar
        var avatarTarget = planeGenerator(8, 20, "#01B0F0");
        avatarTarget.position.set(0, -80, 0);
        avatarTarget.name = 'avatarRot';
        scene.add(avatarTarget);
        res.push(avatarTarget);
        return res;
    }
    ;

    function updateTargets() {
        avatar.updateMatrixWorld(true);
        for (var i = 0; i < targetList.length - 1; i++) {
            var pos = avatar.skeleton.bones[idBonesTargeted[i]].getWorldPosition();
            targetList[i].position.set(pos.x, pos.y, pos.z);
        }
        targetList[targetList.length - 1].position.setX(avatar.position.x)
    }

    function hitTarget(evt) {
        evt.preventDefault();
        evt = evt.originalEvent.changedTouches[0];
        var vector = mouseToWorld(evt);

        mousePosDown = vector.clone();
        mousePosMove = vector.clone();

        var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

        intersects = raycaster.intersectObjects(targetList);

        window.addEventListener("touchend", onMouseUp);
        if (intersects.length > 0) {
            $("#container").on('touchmove', onDocumentMouseMove);
        }
    }

    function onMouseUp(evt) {
        evt.preventDefault();
        $("#container").off();
        loadConsole(avatar.quaternion.y +" - "+avatar.quaternion.w + " = "+avatar.quaternion.y*Math.PI);
        if (intersects.length > 0) {

        } else {
        }
    }
    function onDocumentMouseMove(evt) {
        evt.preventDefault();
        evt = evt.originalEvent.changedTouches[0];
        var tmpMousePosMove = mouseToWorld(evt);
        switch (intersects[0].object.name) {
            case 'rHand':
                var bone = avatar.skeleton.bones[12];
                var angle = getAngle(bone.getWorldPosition(), mousePosMove, tmpMousePosMove);
                mousePosMove = mouseToWorld(evt);
                if (angle){
                    var rot = avatar.quaternion.y*Math.PI;
                    if(Math.abs(rot)<=1.5) {
                        bone.rotateZ(angle);
                    }else if(Math.abs(rot)>=2.7){
                        bone.rotateZ(-angle);
                    }else if(rot>Math.PI/4){
                        bone.rotateX(angle);
                    }else
                    {
                        bone.rotateX(-angle);
                    }
                }
                break;
            case 'lHand':
                var bone = avatar.skeleton.bones[13];
                var angle = getAngle(bone.getWorldPosition(), mousePosMove, tmpMousePosMove);
                mousePosMove = mouseToWorld(evt);
                if (angle){
                    var rot = avatar.quaternion.y*Math.PI;
                    if(Math.abs(rot)<=1.5) {
                        bone.rotateZ(angle);
                    }else if(Math.abs(rot)>=2.7){
                        bone.rotateZ(-angle);
                    }else if(rot>Math.PI/4){
                        bone.rotateX(angle);
                    }else
                    {
                        bone.rotateX(-angle);
                    }
                }
                break;
            case 'head':
                var bone = avatar.skeleton.bones[3];
                var angle = getAngle(bone.getWorldPosition(), mousePosMove, tmpMousePosMove);
                mousePosMove = mouseToWorld(evt);
                if (angle)
                    if(avatar.quaternion.y*Math.PI<0)
                        bone.rotateX(angle);
                    else
                        bone.rotateX(-angle);
                break;
            case 'avatarRot':
                var v1 = mousePosMove.clone().normalize();
                var v2 = tmpMousePosMove.clone().normalize();
                mousePosMove = mouseToWorld(evt);
                avatar.rotateY((v2.x - v1.x) * Math.PI);
                break;
        }
        updateTargets();
    }
    function getAngle(origin, v1, v2) {
        v1.x -= origin.x;
        v2.x -= origin.x;
        v1.y -= origin.y;
        v2.y -= origin.y;
        var cosTeta = (v1.x * v2.x + v1.y * v2.y) / (Math.sqrt(Math.pow(v1.x, 2) + Math.pow(v1.y, 2)) * Math.sqrt(Math.pow(v2.x, 2) + Math.pow(v2.y, 2)));
        var teta = Math.acos(cosTeta);
        if ((( v1.x > 0 && v2.y < 0 || v1.x < 0 && v2.y > 0) && ( v1.y > 0 && v2.x > 0 || v1.y < 0 && v2.x < 0))
                || (v1.x > 0 && v1.y > 0 && v2.x > 0 && v2.y > 0 && (v1.y > v2.y || v1.x < v2.x))
                || (v1.x > 0 && v1.y < 0 && v2.x > 0 && v2.y < 0 && (v1.y > v2.y || v1.x > v2.x))
                || (v1.x < 0 && v1.y < 0 && v2.x < 0 && v2.y < 0 && (v1.y < v2.y || v1.x > v2.x))
                || (v1.x < 0 && v1.y > 0 && v2.x < 0 && v2.y > 0 && (v1.y < v2.y || v1.x < v2.x))
        )
            teta = -teta;
//        if(avatar.rotation.y<0){
//            teta=-teta;
//        }
        return teta;
    }

    function mouseToWorld(evt) {
        var mouseX = (evt.clientX / window.innerWidth) * 2 - 1;
        var mouseY = -(evt.clientY / window.innerHeight) * 2 + 1;

        var vector = new THREE.Vector3(mouseX, mouseY, 0.99799794);//Mystery number = 0.99799794
        vector.unproject(camera);
        return vector;
    }

    function worldToScreen(pos) {
        var p = pos.clone();
        var vector = p.project(camera);

        vector.x = (vector.x + 1) / 2 * window.innerWidth;
        vector.y = -(vector.y - 1) / 2 * window.innerHeight;

        return vector;
    }

    function planeGenerator(width, height, color) {
        var planeGeometry = new THREE.SphereGeometry(width, 100, 100);
        var material = new THREE.MeshPhongMaterial({color: color, visible: true});
        return new THREE.Mesh(planeGeometry, material);
    }
    ;
</script>

</body>
</html>